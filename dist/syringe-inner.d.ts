// Generated by dts-bundle v0.3.0

declare module 'syringe.ts' {
    export { Injector } from '__syringe.ts/injector';
    export { IToken, Token } from '__syringe.ts/token';
    export { ILazy, Lazy } from '__syringe.ts/lazy';
    export { Inject } from '__syringe.ts/decorators';
    export { bind } from '__syringe.ts/binding';
}

declare module '__syringe.ts/injector' {
    import { IBinding } from '__syringe.ts/binding';
    import { IToken } from '__syringe.ts/token';
    export interface IInjector {
            get<T>(token: IToken<T>): Promise<T>;
    }
    /**
        * An Injector resolves tokens to values via bindings.
        */
    export class Injector implements IInjector {
            /**
                * @constructor
                * @param {IBinding<any>[]} bindings The array of bindings to load onto the injector
                * @param {IInjector} [parent] A parent for this injector, which will be delegated to for any tokens unbound on this injector
                */
            constructor(bindings: IBinding<any>[], parent?: IInjector);
            /**
                * Resolves a token to a Promise for a value.
                * @param {IToken<T>} token Token to get
                */
            get<T>(token: IToken<T>): Promise<T>;
    }
}

declare module '__syringe.ts/token' {
    import { IToken } from '__syringe.ts/token';
    export interface IToken<T> {
            new (): Token<T>;
            getDebugName(): string;
    }
    /**
        * A token is an abstract representation of a dependency of a given type.
        */
    export class Token<T> {
            surrogate: T;
            constructor();
            /**
                * Get a human-readable name for the token for debugging purposes.
                */
            static getDebugName(): string;
            /**
                * Create a token.
                * @param {string} [debugName] A human-readable name for the token for debugging purposes.
                */
            static create<T>(debugName?: string): IToken<T>;
    }
}

declare module '__syringe.ts/lazy' {
    import { IToken } from '__syringe.ts/token';
    export interface ILazy<T> {
        get(): Promise<T>;
    }
    /**
      * Get the corresponding Lazy token for a given token.
      * @param {IToken<T>} token The non-lazy token
      */
    export function Lazy<T>(token: IToken<T>): IToken<ILazy<T>>;
}

declare module '__syringe.ts/decorators' {
    import { IToken } from '__syringe.ts/token';
    import { IStaticWithArgs } from '__syringe.ts/shared-interfaces';
    export interface IStaticThatMaybeHasTokens<T, T1, T2, T3, T4, T5, T6, T7, T8> extends IStaticWithArgs<T, T1, T2, T3, T4, T5, T6, T7, T8> {
        ___tokens?: IToken<any>[];
    }
    export interface IInjectDecorator<T1, T2, T3, T4, T5, T6, T7, T8> {
        (Class: IStaticThatMaybeHasTokens<any, T1, T2, T3, T4, T5, T6, T7, T8>): IStaticThatMaybeHasTokens<any, T1, T2, T3, T4, T5, T6, T7, T8>;
    }
    export function Inject(): IInjectDecorator<{}, {}, {}, {}, {}, {}, {}, {}>;
    export function Inject<T1>(token1: IToken<T1>): IInjectDecorator<T1, {}, {}, {}, {}, {}, {}, {}>;
    export function Inject<T1, T2>(token1: IToken<T1>, token2: IToken<T2>): IInjectDecorator<T1, T2, {}, {}, {}, {}, {}, {}>;
    export function Inject<T1, T2, T3>(token1: IToken<T1>, token2: IToken<T2>, token3: IToken<T3>): IInjectDecorator<T1, T2, T3, {}, {}, {}, {}, {}>;
    export function Inject<T1, T2, T3, T4>(token1: IToken<T1>, token2: IToken<T2>, token3: IToken<T3>, token4: IToken<T4>): IInjectDecorator<T1, T2, T3, T4, {}, {}, {}, {}>;
    export function Inject<T1, T2, T3, T4, T5>(token1: IToken<T1>, token2: IToken<T2>, token3: IToken<T3>, token4: IToken<T4>, token5: IToken<T5>): IInjectDecorator<T1, T2, T3, T4, T5, {}, {}, {}>;
    export function Inject<T1, T2, T3, T4, T5, T6>(token1: IToken<T1>, token2: IToken<T2>, token3: IToken<T3>, token4: IToken<T4>, token5: IToken<T5>, token6: IToken<T6>): IInjectDecorator<T1, T2, T3, T4, T5, T6, {}, {}>;
    export function Inject<T1, T2, T3, T4, T5, T6, T7>(token1: IToken<T1>, token2: IToken<T2>, token3: IToken<T3>, token4: IToken<T4>, token5: IToken<T5>, token6: IToken<T6>, token7: IToken<T7>): IInjectDecorator<T1, T2, T3, T4, T5, T6, T7, {}>;
    export function Inject<T1, T2, T3, T4, T5, T6, T7, T8>(token1: IToken<T1>, token2: IToken<T2>, token3: IToken<T3>, token4: IToken<T4>, token5: IToken<T5>, token6: IToken<T6>, token7: IToken<T7>, token8: IToken<T8>): IInjectDecorator<T1, T2, T3, T4, T5, T6, T7, T8>;
}

declare module '__syringe.ts/binding' {
    import { IToken } from '__syringe.ts/token';
    import { IProvider } from '__syringe.ts/provider/facade';
    import { IStaticThatMaybeHasTokens } from '__syringe.ts/decorators';
    import { IStaticWithNoArgs, IStaticWith1Arg, IStaticWith2Args, IStaticWith3Args, IStaticWith4Args, IStaticWith5Args, IStaticWith6Args, IStaticWith7Args, IStaticWith8Args } from '__syringe.ts/shared-interfaces';
    export interface IBinding<T> {
        token: IToken<T>;
        provider: IProvider<T>;
    }
    export interface IUnprovidedBinding<T> {
        toValue(value: T): IBinding<T>;
        toClass(Class: IStaticWithNoArgs<T>): IBinding<T>;
        toClass(Class: IStaticThatMaybeHasTokens<T, any, any, any, any, any, any, any, any>): IBinding<T>;
        toClass<T1>(Class: IStaticWith1Arg<T, T1>, token1: IToken<T1>): IBinding<T>;
        toClass<T1, T2>(Class: IStaticWith2Args<T, T1, T2>, token1: IToken<T1>, token2: IToken<T2>): IBinding<T>;
        toClass<T1, T2, T3>(Class: IStaticWith3Args<T, T1, T2, T3>, token1: IToken<T1>, token2: IToken<T2>, token3: IToken<T3>): IBinding<T>;
        toClass<T1, T2, T3, T4>(Class: IStaticWith4Args<T, T1, T2, T3, T4>, token1: IToken<T1>, token2: IToken<T2>, token3: IToken<T3>, token4: IToken<T4>): IBinding<T>;
        toClass<T1, T2, T3, T4, T5>(Class: IStaticWith5Args<T, T1, T2, T3, T4, T5>, token1: IToken<T1>, token2: IToken<T2>, token3: IToken<T3>, token4: IToken<T4>, token5: IToken<T5>): IBinding<T>;
        toClass<T1, T2, T3, T4, T5, T6>(Class: IStaticWith6Args<T, T1, T2, T3, T4, T5, T6>, token1: IToken<T1>, token2: IToken<T2>, token3: IToken<T3>, token4: IToken<T4>, token5: IToken<T5>, token6: IToken<T6>): IBinding<T>;
        toClass<T1, T2, T3, T4, T5, T6, T7>(Class: IStaticWith7Args<T, T1, T2, T3, T4, T5, T6, T7>, token1: IToken<T1>, token2: IToken<T2>, token3: IToken<T3>, token4: IToken<T4>, token5: IToken<T5>, token6: IToken<T6>, token7: IToken<T7>): IBinding<T>;
        toClass<T1, T2, T3, T4, T5, T6, T7, T8>(Class: IStaticWith8Args<T, T1, T2, T3, T4, T5, T6, T7, T8>, token1: IToken<T1>, token2: IToken<T2>, token3: IToken<T3>, token4: IToken<T4>, token5: IToken<T5>, token6: IToken<T6>, token7: IToken<T7>, token8: IToken<T8>): IBinding<T>;
        toFactory(factory: () => T): IBinding<T>;
        toFactory<T1>(factory: (dep1: T1) => T, token1: IToken<T1>): IBinding<T>;
        toFactory<T1, T2>(factory: (dep1: T1, dep2: T2) => T, token1: IToken<T1>, token2: IToken<T2>): IBinding<T>;
        toFactory<T1, T2, T3>(factory: (dep1: T1, dep2: T2, dep3: T3) => T, token1: IToken<T1>, token2: IToken<T2>, token3: IToken<T3>): IBinding<T>;
        toFactory<T1, T2, T3, T4>(factory: (dep1: T1, dep2: T2, dep3: T3, dep4: T4) => T, token1: IToken<T1>, token2: IToken<T2>, token3: IToken<T3>, token4: IToken<T4>): IBinding<T>;
        toFactory<T1, T2, T3, T4, T5>(factory: (dep1: T1, dep2: T2, dep3: T3, dep4: T4, dep5: T5) => T, token1: IToken<T1>, token2: IToken<T2>, token3: IToken<T3>, token4: IToken<T4>, token5: IToken<T5>): IBinding<T>;
        toFactory<T1, T2, T3, T4, T5, T6>(factory: (dep1: T1, dep2: T2, dep3: T3, dep4: T4, dep5: T5, dep6: T6) => T, token1: IToken<T1>, token2: IToken<T2>, token3: IToken<T3>, token4: IToken<T4>, token5: IToken<T5>, token6: IToken<T6>): IBinding<T>;
        toFactory<T1, T2, T3, T4, T5, T6, T7>(factory: (dep1: T1, dep2: T2, dep3: T3, dep4: T4, dep5: T5, dep6: T6, dep7: T7) => T, token1: IToken<T1>, token2: IToken<T2>, token3: IToken<T3>, token4: IToken<T4>, token5: IToken<T5>, token6: IToken<T6>, token7: IToken<T7>): IBinding<T>;
        toFactory<T1, T2, T3, T4, T5, T6, T7, T8>(factory: (dep1: T1, dep2: T2, dep3: T3, dep4: T4, dep5: T5, dep6: T7, dep7: T7, dep8: T8) => T, token1: IToken<T1>, token2: IToken<T2>, token3: IToken<T3>, token4: IToken<T4>, token5: IToken<T5>, token6: IToken<T6>, token7: IToken<T7>, token8: IToken<T8>): IBinding<T>;
        toAsyncFactory(factory: () => Thenable<T>): IBinding<T>;
        toAsyncFactory<T1>(factory: (dep1: T1) => Thenable<T>, token1: IToken<T1>): IBinding<T>;
        toAsyncFactory<T1, T2>(factory: (dep1: T1, dep2: T2) => Thenable<T>, token1: IToken<T1>, token2: IToken<T2>): IBinding<T>;
        toAsyncFactory<T1, T2, T3>(factory: (dep1: T1, dep2: T2, dep3: T3) => Thenable<T>, token1: IToken<T1>, token2: IToken<T2>, token3: IToken<T3>): IBinding<T>;
        toAsyncFactory<T1, T2, T3, T4>(factory: (dep1: T1, dep2: T2, dep3: T3, dep4: T4) => Thenable<T>, token1: IToken<T1>, token2: IToken<T2>, token3: IToken<T3>, token4: IToken<T4>): IBinding<T>;
        toAsyncFactory<T1, T2, T3, T4, T5>(factory: (dep1: T1, dep2: T2, dep3: T3, dep4: T4, dep5: T5) => Thenable<T>, token1: IToken<T1>, token2: IToken<T2>, token3: IToken<T3>, token4: IToken<T4>, token5: IToken<T5>): IBinding<T>;
        toAsyncFactory<T1, T2, T3, T4, T5, T6>(factory: (dep1: T1, dep2: T2, dep3: T3, dep4: T4, dep5: T5, dep6: T6) => Thenable<T>, token1: IToken<T1>, token2: IToken<T2>, token3: IToken<T3>, token4: IToken<T4>, token5: IToken<T5>, token6: IToken<T6>): IBinding<T>;
        toAsyncFactory<T1, T2, T3, T4, T5, T6, T7>(factory: (dep1: T1, dep2: T2, dep3: T3, dep4: T4, dep5: T5, dep6: T6, dep7: T7) => Thenable<T>, token1: IToken<T1>, token2: IToken<T2>, token3: IToken<T3>, token4: IToken<T4>, token5: IToken<T5>, token6: IToken<T6>, token7: IToken<T7>): IBinding<T>;
        toAsyncFactory<T1, T2, T3, T4, T5, T6, T7, T8>(factory: (dep1: T1, dep2: T2, dep3: T3, dep4: T4, dep5: T5, dep6: T6, dep7: T7, dep8: T8) => Thenable<T>, token1: IToken<T1>, token2: IToken<T2>, token3: IToken<T3>, token4: IToken<T4>, token5: IToken<T5>, token6: IToken<T6>, token7: IToken<T7>, token8: IToken<T8>): IBinding<T>;
    }
    /**
      * Start binding a token.
      * @param {IToken<T>} token The token to bind
      */
    export function bind<T>(token: IToken<T>): IUnprovidedBinding<T>;
}

declare module '__syringe.ts/shared-interfaces' {
    export interface IStatic<T> {
        new (...args: any[]): T;
    }
    export interface IStaticWithNoArgs<T> {
        new (): T;
    }
    export interface IStaticWith1Arg<T, T1> {
        new (dep1: T1): T;
    }
    export interface IStaticWith2Args<T, T1, T2> {
        new (dep1: T1, dep2: T2): T;
    }
    export interface IStaticWith3Args<T, T1, T2, T3> {
        new (dep1: T1, dep2: T2, dep3: T3): T;
    }
    export interface IStaticWith4Args<T, T1, T2, T3, T4> {
        new (dep1: T1, dep2: T2, dep3: T3, dep4: T4): T;
    }
    export interface IStaticWith5Args<T, T1, T2, T3, T4, T5> {
        new (dep1: T1, dep2: T2, dep3: T3, dep4: T4, dep5: T5): T;
    }
    export interface IStaticWith6Args<T, T1, T2, T3, T4, T5, T6> {
        new (dep1: T1, dep2: T2, dep3: T3, dep4: T4, dep5: T5, dep6: T6): T;
    }
    export interface IStaticWith7Args<T, T1, T2, T3, T4, T5, T6, T7> {
        new (dep1: T1, dep2: T2, dep3: T3, dep4: T4, dep5: T5, dep6: T6, dep7: T7): T;
    }
    export interface IStaticWith8Args<T, T1, T2, T3, T4, T5, T6, T7, T8> {
        new (dep1: T1, dep2: T2, dep3: T3, dep4: T4, dep5: T5, dep6: T6, dep7: T7, dep8: T8): T;
    }
    export interface IStaticWithArgs<T, T1, T2, T3, T4, T5, T6, T7, T8> extends IStatic<T> {
        new (dep1: T1, dep2: T2, dep3: T3, dep4: T4, dep5: T5, dep6: T6, dep7: T7, dep8: T8): T;
    }
}

declare module '__syringe.ts/provider/facade' {
    export * from '__syringe.ts/provider/value';
    export * from '__syringe.ts/provider/factory';
    export * from '__syringe.ts/provider/indexed';
    export * from '__syringe.ts/provider/class';
    export * from '__syringe.ts/provider/abstract';
}

declare module '__syringe.ts/provider/value' {
    import { IToken } from '__syringe.ts/token';
    import { IProvider } from '__syringe.ts/provider/abstract';
    /**
      * Provider that gets values by returning a constant value.
      */
    export class ValueProvider<T> implements IProvider<T> {
        dependencyTokens: IToken<any>[];
        constructor(value: T);
        get(...dependencies: any[]): Promise<T>;
    }
}

declare module '__syringe.ts/provider/factory' {
    import { IToken } from '__syringe.ts/token';
    import { IProvider } from '__syringe.ts/provider/abstract';
    /**
        * Provider that gets values by invoking a factory function.
        */
    export class FactoryProvider<T> implements IProvider<T> {
            dependencyTokens: IToken<any>[];
            constructor(factory: (...deps: any[]) => T, dependencyTokens: IToken<any>[]);
            get(dependencies: any[]): Promise<T>;
    }
    /**
        * Provider that gets a Promise for values by invoking a factory function.
        */
    export class AsyncFactoryProvider<T> implements IProvider<T> {
            dependencyTokens: IToken<any>[];
            constructor(factory: (...deps: any[]) => Thenable<T>, dependencyTokens: IToken<any>[]);
            get(dependencies: any[]): Promise<T>;
    }
}

declare module '__syringe.ts/provider/indexed' {
    import { IToken } from '__syringe.ts/token';
    import { IProvider } from '__syringe.ts/provider/abstract';
    /**
      * Provider that wraps another provider but indexes the dependency tokens
      * within the context of an Injector.
      */
    export class IndexedProvider<T> implements IProvider<T> {
        dependencyTokens: IToken<any>[];
        dependencyIndices: number[];
        constructor(provider: IProvider<T>, getIndexForToken: (token: IToken<any>) => number);
        get(dependencies: any[]): Promise<T>;
    }
}

declare module '__syringe.ts/provider/class' {
    import { IToken } from '__syringe.ts/token';
    import { IProvider } from '__syringe.ts/provider/abstract';
    import { IStaticThatMaybeHasTokens } from '__syringe.ts/decorators';
    /**
      * Provider that gets values by constructing an instance of a class.
      */
    export class ClassProvider<T> implements IProvider<T> {
        dependencyTokens: IToken<any>[];
        constructor(Class: IStaticThatMaybeHasTokens<any, any, any, any, any, any, any, any, any>, dependencyTokens: IToken<any>[]);
        get(dependencies: any[]): Promise<T>;
    }
}

declare module '__syringe.ts/provider/abstract' {
    import { IToken } from '__syringe.ts/token';
    /**
      * A provider is recipe for building a value that may have dependencies.
      */
    export interface IProvider<T> {
        dependencyTokens: IToken<any>[];
        get(dependencies: any[]): Promise<T>;
    }
}

