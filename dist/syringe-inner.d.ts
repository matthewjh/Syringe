// Generated by dts-bundle v0.3.0

declare module 'syringe.ts' {
    export { Injector } from '__syringe.ts/injector';
    export { IToken, Token } from '__syringe.ts/token';
    export { ILazy, Lazy } from '__syringe.ts/lazy';
    export { Inject } from '__syringe.ts/decorators';
    export { bind } from '__syringe.ts/binding';
}

declare module '__syringe.ts/injector' {
    import { IBinding } from '__syringe.ts/binding';
    import { IToken } from '__syringe.ts/token';
    export interface IInjector {
        get<T>(token: IToken<T>): Promise<T>;
    }
    export class Injector implements IInjector {
        constructor(bindings: IBinding<any>[], parent?: IInjector);
        get<T>(token: IToken<T>): Promise<T>;
    }
}

declare module '__syringe.ts/token' {
    import { IToken } from '__syringe.ts/token';
    export interface IToken<T> {
        new (): Token<T>;
        getDebugName(): string;
    }
    export class Token<T> {
        surrogate: T;
        constructor();
        static getDebugName(): string;
        static create<T>(debugName?: string): IToken<T>;
    }
}

declare module '__syringe.ts/lazy' {
    import { IToken } from '__syringe.ts/token';
    export interface ILazy<T> {
        get(): Promise<T>;
    }
    export function Lazy<T>(token: IToken<T>): IToken<ILazy<T>>;
}

declare module '__syringe.ts/decorators' {
    import { IToken } from '__syringe.ts/token';
    import { IStaticWithArgs } from '__syringe.ts/shared-interfaces';
    export interface IStaticThatMaybeHasTokens<T, T1, T2, T3, T4, T5, T6, T7, T8> extends IStaticWithArgs<T, T1, T2, T3, T4, T5, T6, T7, T8> {
        ___tokens?: IToken<any>[];
    }
    export interface IInjectDecorator<T1, T2, T3, T4, T5, T6, T7, T8> {
        (Class: IStaticThatMaybeHasTokens<any, T1, T2, T3, T4, T5, T6, T7, T8>): IStaticThatMaybeHasTokens<any, T1, T2, T3, T4, T5, T6, T7, T8>;
    }
    export function Inject<T1, T2, T3, T4, T5, T6, T7, T8>(token1?: IToken<T1>, token2?: IToken<T2>, token3?: IToken<T3>, token4?: IToken<T4>, token5?: IToken<T5>, token6?: IToken<T6>, token7?: IToken<T7>, token8?: IToken<T8>): IInjectDecorator<T1, T2, T3, T4, T5, T6, T7, T8>;
}

declare module '__syringe.ts/binding' {
    import { IToken } from '__syringe.ts/token';
    import { IProvider } from '__syringe.ts/provider/facade';
    import { IStaticWithArgs, IStatic } from '__syringe.ts/shared-interfaces';
    export interface IBinding<T> {
        token: IToken<T>;
        provider: IProvider<T>;
    }
    export interface IUnprovidedBinding<T> {
        toValue(value: T): IBinding<T>;
        toClass(Class: IStatic<T>): IBinding<T>;
        toClass<T1>(Class: IStaticWithArgs<T, T1, {}, {}, {}, {}, {}, {}, {}>, token1: IToken<T1>): IBinding<T>;
        toClass<T1, T2>(Class: IStaticWithArgs<T, T1, T2, {}, {}, {}, {}, {}, {}>, token1: IToken<T1>, token2: IToken<T2>): IBinding<T>;
        toClass<T1, T2, T3>(Class: IStaticWithArgs<T, T1, T2, T3, {}, {}, {}, {}, {}>, token1: IToken<T1>, token2: IToken<T2>, token3: IToken<T3>): IBinding<T>;
        toClass<T1, T2, T3, T4>(Class: IStaticWithArgs<T, T1, T2, T3, T4, {}, {}, {}, {}>, token1: IToken<T1>, token2: IToken<T2>, token3: IToken<T3>, token4: IToken<T4>): IBinding<T>;
        toClass<T1, T2, T3, T4, T5>(Class: IStaticWithArgs<T, T1, T2, T3, T4, T5, {}, {}, {}>, token1: IToken<T1>, token2: IToken<T2>, token3: IToken<T3>, token4: IToken<T4>, token5: IToken<T5>): IBinding<T>;
        toClass<T1, T2, T3, T4, T5, T6>(Class: IStaticWithArgs<T, T1, T2, T3, T4, T5, T6, {}, {}>, token1: IToken<T1>, token2: IToken<T2>, token3: IToken<T3>, token4: IToken<T4>, token5: IToken<T5>, token6: IToken<T6>): IBinding<T>;
        toClass<T1, T2, T3, T4, T5, T6, T7>(Class: IStaticWithArgs<T, T1, T2, T3, T4, T5, T6, T7, {}>, token1: IToken<T1>, token2: IToken<T2>, token3: IToken<T3>, token4: IToken<T4>, token5: IToken<T5>, token6: IToken<T6>, token7: IToken<T7>): IBinding<T>;
        toClass<T1, T2, T3, T4, T5, T6, T7, T8>(Class: IStaticWithArgs<T, T1, T2, T3, T4, T5, T6, T7, T8>, token1: IToken<T1>, token2: IToken<T2>, token3: IToken<T3>, token4: IToken<T4>, token5: IToken<T5>, token6: IToken<T6>, token7: IToken<T7>, token8: IToken<T8>): IBinding<T>;
        toFactory(factory: () => T): IBinding<T>;
        toFactory<T1>(factory: (dep1: T1) => T, token1: IToken<T1>): IBinding<T>;
        toFactory<T1, T2>(factory: (dep1: T1, dep2: T2) => T, token1: IToken<T1>, token2: IToken<T2>): IBinding<T>;
        toFactory<T1, T2, T3>(factory: (dep1: T1, dep2: T2, dep3: T3) => T, token1: IToken<T1>, token2: IToken<T2>, token3: IToken<T3>): IBinding<T>;
        toFactory<T1, T2, T3, T4>(factory: (dep1: T1, dep2: T2, dep3: T3, dep4: T4) => T, token1: IToken<T1>, token2: IToken<T2>, token3: IToken<T3>, token4: IToken<T4>): IBinding<T>;
        toFactory<T1, T2, T3, T4, T5>(factory: (dep1: T1, dep2: T2, dep3: T3, dep4: T4, dep5: T5) => T, token1: IToken<T1>, token2: IToken<T2>, token3: IToken<T3>, token4: IToken<T4>, token5: IToken<T5>): IBinding<T>;
        toFactory<T1, T2, T3, T4, T5, T6>(factory: (dep1: T1, dep2: T2, dep3: T3, dep4: T4, dep5: T5, dep6: T6) => T, token1: IToken<T1>, token2: IToken<T2>, token3: IToken<T3>, token4: IToken<T4>, token5: IToken<T5>, token6: IToken<T6>): IBinding<T>;
        toFactory<T1, T2, T3, T4, T5, T6, T7>(factory: (dep1: T1, dep2: T2, dep3: T3, dep4: T4, dep5: T5, dep6: T6, dep7: T7) => T, token1: IToken<T1>, token2: IToken<T2>, token3: IToken<T3>, token4: IToken<T4>, token5: IToken<T5>, token6: IToken<T6>, token7: IToken<T7>): IBinding<T>;
        toFactory<T1, T2, T3, T4, T5, T6, T7, T8>(factory: (dep1: T1, dep2: T2, dep3: T3, dep4: T4, dep5: T5, dep6: T7, dep7: T7, dep8: T8) => T, token1: IToken<T1>, token2: IToken<T2>, token3: IToken<T3>, token4: IToken<T4>, token5: IToken<T5>, token6: IToken<T6>, token7: IToken<T7>, token8: IToken<T8>): IBinding<T>;
        toAsyncFactory(factory: () => Thenable<T>): IBinding<T>;
        toAsyncFactory<T1>(factory: (dep1: T1) => Thenable<T>, token1: IToken<T1>): IBinding<T>;
        toAsyncFactory<T1, T2>(factory: (dep1: T1, dep2: T2) => Thenable<T>, token1: IToken<T1>, token2: IToken<T2>): IBinding<T>;
        toAsyncFactory<T1, T2, T3>(factory: (dep1: T1, dep2: T2, dep3: T3) => Thenable<T>, token1: IToken<T1>, token2: IToken<T2>, token3: IToken<T3>): IBinding<T>;
        toAsyncFactory<T1, T2, T3, T4>(factory: (dep1: T1, dep2: T2, dep3: T3, dep4: T4) => Thenable<T>, token1: IToken<T1>, token2: IToken<T2>, token3: IToken<T3>, token4: IToken<T4>): IBinding<T>;
        toAsyncFactory<T1, T2, T3, T4, T5>(factory: (dep1: T1, dep2: T2, dep3: T3, dep4: T4, dep5: T5) => Thenable<T>, token1: IToken<T1>, token2: IToken<T2>, token3: IToken<T3>, token4: IToken<T4>, token5: IToken<T5>): IBinding<T>;
        toAsyncFactory<T1, T2, T3, T4, T5, T6>(factory: (dep1: T1, dep2: T2, dep3: T3, dep4: T4, dep5: T5, dep6: T6) => Thenable<T>, token1: IToken<T1>, token2: IToken<T2>, token3: IToken<T3>, token4: IToken<T4>, token5: IToken<T5>, token6: IToken<T6>): IBinding<T>;
        toAsyncFactory<T1, T2, T3, T4, T5, T6, T7>(factory: (dep1: T1, dep2: T2, dep3: T3, dep4: T4, dep5: T5, dep6: T6, dep7: T7) => Thenable<T>, token1: IToken<T1>, token2: IToken<T2>, token3: IToken<T3>, token4: IToken<T4>, token5: IToken<T5>, token6: IToken<T6>, token7: IToken<T7>): IBinding<T>;
        toAsyncFactory<T1, T2, T3, T4, T5, T6, T7, T8>(factory: (dep1: T1, dep2: T2, dep3: T3, dep4: T4, dep5: T5, dep6: T6, dep7: T7, dep8: T8) => Thenable<T>, token1: IToken<T1>, token2: IToken<T2>, token3: IToken<T3>, token4: IToken<T4>, token5: IToken<T5>, token6: IToken<T6>, token7: IToken<T7>, token8: IToken<T8>): IBinding<T>;
    }
    export function bind<T>(token: IToken<T>): IUnprovidedBinding<T>;
}

declare module '__syringe.ts/shared-interfaces' {
    export interface IStatic<T> {
        new (...args: any[]): T;
    }
    export interface IStaticWithArgs<T, T1, T2, T3, T4, T5, T6, T7, T8> extends IStatic<T> {
        new (dep1: T1, dep2: T2, dep3: T3, dep4: T4, dep5: T5, dep6: T6, dep7: T7, dep8: T8): T;
    }
}

declare module '__syringe.ts/provider/facade' {
    export * from '__syringe.ts/provider/value';
    export * from '__syringe.ts/provider/factory';
    export * from '__syringe.ts/provider/indexed';
    export * from '__syringe.ts/provider/class';
    export * from '__syringe.ts/provider/abstract';
}

declare module '__syringe.ts/provider/value' {
    import { IToken } from '__syringe.ts/token';
    import { IProvider } from '__syringe.ts/provider/abstract';
    export class ValueProvider<T> implements IProvider<T> {
        dependencyTokens: IToken<any>[];
        constructor(value: T);
        get(...dependencies: any[]): Promise<T>;
    }
}

declare module '__syringe.ts/provider/factory' {
    import { IToken } from '__syringe.ts/token';
    import { IProvider } from '__syringe.ts/provider/abstract';
    export class FactoryProvider<T> implements IProvider<T> {
        dependencyTokens: IToken<any>[];
        constructor(factory: (...deps: any[]) => T, dependencyTokens: IToken<any>[]);
        get(dependencies: any[]): Promise<T>;
    }
    export class AsyncFactoryProvider<T> implements IProvider<T> {
        dependencyTokens: IToken<any>[];
        constructor(factory: (...deps: any[]) => Thenable<T>, dependencyTokens: IToken<any>[]);
        get(dependencies: any[]): Promise<T>;
    }
}

declare module '__syringe.ts/provider/indexed' {
    import { IToken } from '__syringe.ts/token';
    import { IProvider } from '__syringe.ts/provider/abstract';
    export class IndexedProvider<T> implements IProvider<T> {
        dependencyTokens: IToken<any>[];
        dependencyIndices: number[];
        constructor(provider: IProvider<T>, getIndexForToken: (token: IToken<any>) => number);
        get(dependencies: any[]): Promise<T>;
    }
}

declare module '__syringe.ts/provider/class' {
    import { IToken } from '__syringe.ts/token';
    import { IProvider } from '__syringe.ts/provider/abstract';
    import { IStaticThatMaybeHasTokens } from '__syringe.ts/decorators';
    export class ClassProvider<T> implements IProvider<T> {
        dependencyTokens: IToken<any>[];
        constructor(Class: IStaticThatMaybeHasTokens<any, any, any, any, any, any, any, any, any>, dependencyTokens: IToken<any>[]);
        get(dependencies: any[]): Promise<T>;
    }
}

declare module '__syringe.ts/provider/abstract' {
    import { IToken } from '__syringe.ts/token';
    export interface IProvider<T> {
        dependencyTokens: IToken<any>[];
        get(dependencies: any[]): Promise<T>;
    }
}

